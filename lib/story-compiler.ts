/**
 * Story Compiler - Converts structured story schema to Svelte components
 * Eliminates AI hallucination by generating deterministic code
 */

import type { StorySchema, StoryStep, StoryVisual, ComponentName } from './story-schema.js';
import type { ComponentInfo } from './component-registry.js';
import { componentRegistry, validateComponentProps } from './component-registry.js';
import { validateStorySchema } from './story-schema.js';

export interface CompilerOptions {
  outputPath?: string;
  template?: 'two-column' | 'full-width' | 'custom';
  validation?: boolean;
  minify?: boolean;
}

export interface CompilerResult {
  success: boolean;
  svelte: string;
  layout: string;
  errors: string[];
  warnings: string[];
}

export class StoryCompiler {
  constructor(private options: CompilerOptions = {}) {}

  compile(story: StorySchema): CompilerResult {
    const result: CompilerResult = {
      success: false,
      svelte: '',
      layout: '',
      errors: [],
      warnings: []
    };

    // Validate schema first
    if (this.options.validation !== false) {
      const validation = validateStorySchema(story);
      if (!validation.valid) {
        result.errors = validation.errors;
        return result;
      }
    }

    try {
      // Generate the Svelte component
      result.svelte = this.generateSvelteComponent(story);
      result.layout = this.generateLayoutFile(story);
      result.success = true;
    } catch (error) {
      result.errors.push(`Compilation error: ${error}`);
    }

    return result;
  }

  private generateSvelteComponent(story: StorySchema): string {
    const imports = this.generateImports(story);
    const script = this.generateScript(story);
    const template = this.generateTemplate(story);
    const styles = this.generateStyles(story);

    return `<!-- Generated by Story Compiler -->
${script}

${template}

${styles}`;
  }

  private generateImports(story: StorySchema): string[] {
    const imports = [
      "import { onMount, onDestroy } from 'svelte';",
      "import { scroller } from '$utils/scroll';",
      "import {",
      "  SEO,",
      "  SiteHeader,",
      "  SiteFooter,",
      "  Theme,",
      "  SiteHeadline,",
      "  BodyText,",
      "  EndNotes,",
      "} from '@reuters-graphics/graphics-components';",
      "import { assets } from '$app/paths';",
      "import { page } from '$app/state';",
      "import pkg from '$pkg';"
    ];

    // Add component imports
    const componentImports = this.getUniqueComponents(story);
    componentImports.forEach(component => {
      imports.push(`import ${component} from '$lib/components/charts/${component}.svelte';`);
    });

    // Add stylesheets
    imports.push(
      "import '@reuters-graphics/graphics-components/scss/main.scss';",
      "import '$lib/styles/global.scss';"
    );

    return imports;
  }

  private generateScript(story: StorySchema): string {
    const imports = this.generateImports(story).join('\n  ');
    
    return `<script lang="ts">
  ${imports}

  // Story data and state
  let currentStep = 0;
  let scrollerInstance: any;
  
  // Story metadata
  const storyData = {
    seoTitle: "${story.meta.title}",
    seoDescription: "${story.meta.description || ''}",
    shareTitle: "${story.meta.title}",
    shareDescription: "${story.meta.description || ''}",
    shareImgPath: "${story.meta.shareImage || 'images/reuters-graphics.jpg'}",
    shareImgAlt: "${story.meta.shareImageAlt || 'Story preview'}",
    hed: "${story.meta.title}",
    section: "${story.meta.section || 'Graphics'}",
    sectionUrl: "${story.meta.sectionUrl || 'https://www.reuters.com/graphics/'}",
    authors: ${JSON.stringify(story.meta.authors)},
    publishTime: "${story.meta.publishDate || new Date().toISOString()}",
    updateTime: "",
    endNotes: []
  };

  // Component state management
  ${this.generateStateVariables(story)}

  // Initialize scroller
  onMount(() => {
    scrollerInstance = scroller({
      step: '.step',
      offset: 0.8,
      progress: (i) => {
        currentStep = i;
        updateVisuals(i);
      },
      debug: false
    });
  });

  onDestroy(() => {
    if (scrollerInstance) {
      scrollerInstance.destroy();
    }
  });

  // Visual state management
  ${this.generateStateUpdateFunction(story)}
</script>`;
  }

  private generateTemplate(story: StorySchema): string {
    const layout = story.layout || { type: 'two-column', sticky: 'graphic' };
    
    return `<SEO
  baseUrl={import.meta.env.BASE_URL}
  pageUrl={page.url}
  seoTitle={storyData.seoTitle}
  seoDescription={storyData.seoDescription}
  shareTitle={storyData.shareTitle}
  shareDescription={storyData.shareDescription}
  shareImgPath={\`\${assets}/\${storyData.shareImgPath}\`}
  shareImgAlt={storyData.shareImgAlt}
  publishTime={pkg?.reuters?.graphic?.published}
  updateTime={pkg?.reuters?.graphic?.updated}
  authors={pkg?.reuters?.graphic?.authors}
/>

<Theme base="light">
  <SiteHeader />
  
  <div class="scrollytelling-container ${layout.type}">
    ${this.generateLayoutTemplate(story, layout)}
  </div>

  <SiteFooter />
</Theme>`;
  }

  private generateLayoutTemplate(story: StorySchema, layout: any): string {
    if (layout.type === 'two-column') {
      return `
    <!-- Sticky graphic pane -->
    <div class="graphic-pane">
      ${this.generateVisualSwitcher(story)}
    </div>

    <!-- Scrollable text content -->  
    <div class="text-content">
      ${this.generateStoryHeader(story)}
      ${this.generateSteps(story)}
    </div>`;
    }
    
    // Add other layout types as needed
    return this.generateSteps(story);
  }

  private generateVisualSwitcher(story: StorySchema): string {
    const visualSteps = story.steps.filter(step => step.visual);
    
    if (visualSteps.length === 0) {
      return '<div class="placeholder">No visualizations defined</div>';
    }

    const cases = visualSteps.map((step, index) => {
      const component = step.visual!.component;
      const props = this.generatePropsString(step.visual!);
      
      return `  {:else if currentStep === ${story.steps.indexOf(step)}}
    <${component}${props} />`;
    }).join('\n');

    return `{#if currentStep === 0}
  <div class="intro-placeholder">
    <h3>Story Introduction</h3>
    <p>Scroll down to begin</p>
  </div>
${cases}
{:else}
  <div class="placeholder">
    <h3>Step {currentStep}</h3>
  </div>
{/if}`;
  }

  private generateStoryHeader(story: StorySchema): string {
    return `<SiteHeadline
  hed={storyData.hed}
  section={storyData.section}
  sectionUrl={storyData.sectionUrl}
  authors={storyData.authors}
  publishTime={storyData.publishTime}
  updateTime={storyData.updateTime}
/>`;
  }

  private generateSteps(story: StorySchema): string {
    return story.steps.map((step, index) => {
      const spacing = step.layout?.spacing || 'normal';
      const background = step.layout?.background || 'white';
      
      let content = '';
      
      if (step.content?.headline) {
        content += `<h2>${step.content.headline}</h2>`;
      }
      
      if (step.content?.text) {
        content += `<BodyText text="${step.content.text}" />`;
      }
      
      if (step.content?.quote) {
        content += `<blockquote>
          <p>"${step.content.quote.text}"</p>
          ${step.content.quote.attribution ? `<cite>${step.content.quote.attribution}</cite>` : ''}
        </blockquote>`;
      }

      return `
      <section class="step step-${index} spacing-${spacing}" style="background: ${background}">
        ${content}
      </section>`;
    }).join('\n');
  }

  private generateStateVariables(story: StorySchema): string {
    const visualSteps = story.steps.filter(step => step.visual);
    const components = new Set(visualSteps.map(step => step.visual!.component));
    
    return Array.from(components).map(component => {
      return `let ${component.toLowerCase()}State = {};`;
    }).join('\n  ');
  }

  private generateStateUpdateFunction(story: StorySchema): string {
    const visualSteps = story.steps.filter(step => step.visual);
    
    const cases = visualSteps.map((step, index) => {
      const stepIndex = story.steps.indexOf(step);
      const state = step.visual!.state;
      
      if (!state) return '';
      
      return `    case ${stepIndex}:
      // Update state for step ${step.id}
      ${this.generateStateUpdate(step.visual!)}
      break;`;
    }).filter(Boolean).join('\n');

    return `function updateVisuals(stepIndex: number) {
    switch(stepIndex) {
${cases}
    }
  }`;
  }

  private generateStateUpdate(visual: StoryVisual): string {
    if (!visual.state) return '';
    
    const component = visual.component.toLowerCase();
    const updates: string[] = [];
    
    if (visual.state.zoom) {
      updates.push(`${component}State.zoom = ${JSON.stringify(visual.state.zoom)};`);
    }
    
    if (visual.state.highlight) {
      updates.push(`${component}State.highlight = ${JSON.stringify(visual.state.highlight)};`);
    }
    
    if (visual.state.filter) {
      updates.push(`${component}State.filter = ${JSON.stringify(visual.state.filter)};`);
    }
    
    return updates.join('\n      ');
  }

  private generatePropsString(visual: StoryVisual): string {
    const props: string[] = [];
    
    if (visual.props) {
      Object.entries(visual.props).forEach(([key, value]) => {
        if (typeof value === 'string') {
          props.push(`${key}="${value}"`);
        } else {
          props.push(`${key}={${JSON.stringify(value)}}`);
        }
      });
    }
    
    if (visual.data) {
      if (typeof visual.data === 'string') {
        props.push(`data="${visual.data}"`);
      } else {
        props.push(`data={${JSON.stringify(visual.data)}}`);
      }
    }
    
    // Add state binding
    const component = visual.component.toLowerCase();
    props.push(`bind:state={${component}State}`);
    
    return props.length > 0 ? ' ' + props.join(' ') : '';
  }

  private generateStyles(story: StorySchema): string {
    const layout = story.layout || { type: 'two-column' };
    
    return `<style lang="scss">
  .scrollytelling-container {
    max-width: 1200px;
    margin: 0 auto;
    padding: 0 1rem;
    min-height: 100vh;

    &.two-column {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 2rem;
    }

    &.full-width {
      max-width: 100%;
      padding: 0;
    }

    &.centered {
      max-width: 800px;
      margin: 0 auto;
    }
  }

  .graphic-pane {
    position: sticky;
    top: 2rem;
    height: 80vh;
    display: flex;
    align-items: center;
    justify-content: center;
    background: #f8f9fa;
    border-radius: 8px;
    overflow: hidden;
  }

  .text-content {
    padding: 2rem 0;
  }

  .step {
    margin-bottom: 100vh;
    padding: 2rem;
    border-radius: 8px;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);

    &.spacing-compact {
      margin-bottom: 50vh;
      padding: 1rem;
    }

    &.spacing-spacious {
      margin-bottom: 150vh;
      padding: 3rem;
    }
  }

  .placeholder, .intro-placeholder {
    text-align: center;
    color: #666;
    
    h3 {
      font-size: 2rem;
      margin-bottom: 1rem;
    }
  }

  blockquote {
    border-left: 4px solid #f16e23;
    padding-left: 1rem;
    margin: 1rem 0;
    font-style: italic;

    cite {
      display: block;
      margin-top: 0.5rem;
      font-size: 0.9rem;
      color: #666;
      
      &::before {
        content: "— ";
      }
    }
  }

  @media (max-width: 768px) {
    .scrollytelling-container.two-column {
      grid-template-columns: 1fr;
      gap: 1rem;
    }

    .graphic-pane {
      position: relative;
      height: 50vh;
      top: 0;
    }

    .step {
      margin-bottom: 50vh;
    }
  }
</style>`;
  }

  private generateLayoutFile(story: StorySchema): string {
    return `import type { LayoutLoad } from './$types.js';

export const load: LayoutLoad = async () => {
  return {
    // Add any data loading logic here
  };
};`;
  }

  private getUniqueComponents(story: StorySchema): ComponentName[] {
    const components = new Set<ComponentName>();
    
    story.steps.forEach(step => {
      if (step.visual?.component) {
        components.add(step.visual.component);
      }
    });
    
    return Array.from(components);
  }
}

// Utility function for CLI usage
export function compileStoryFromYAML(yamlContent: string, options: CompilerOptions = {}): CompilerResult {
  try {
    const story = JSON.parse(yamlContent) as StorySchema; // For now, using JSON. Can add YAML parser later
    const compiler = new StoryCompiler(options);
    return compiler.compile(story);
  } catch (error) {
    return {
      success: false,
      svelte: '',
      layout: '',
      errors: [`YAML parsing error: ${error}`],
      warnings: []
    };
  }
}